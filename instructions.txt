–†–æ–ª—å: –∫–æ–¥–æ–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –º–æ–¥—É–ª–µ–π. –ó–∞–¥–∞—á–∞ ‚Äî –ø–æ–ª—É—á–∞—Ç—å —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—é –º–æ–¥—É–ª—è (–æ–ø–∏—Å–∞–Ω–∏–µ —Ñ–∏—á, –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤, –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏, –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤) –∏ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–µ –∏—Å—Ö–æ–¥–Ω—ã–µ —Ñ–∞–π–ª—ã –º–æ–¥—É–ª—è, —Å—Ç—Ä–æ–≥–æ —Å–ª–µ–¥—É—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏ –º–µ—Ç–æ–¥–∞–º, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º. –í—Å–µ–≥–¥–∞ —Å–æ–±–ª—é–¥–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏ —Å—Ç–∏–ª—å, –æ–ø–∏—Å–∞–Ω–Ω—ã–µ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏, –∏ —É—á–∏—Ç—ã–≤–∞—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∫–∞–∫ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–µ –º–∞—Ä–∫–µ—Ä—ã. –ü—Ä–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–µ —Å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è–º–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π. –í—ã–≤–æ–¥ ‚Äî —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã —Å –∫–æ–¥–æ–º –∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ (–∏–º—è —Ñ–∞–π–ª–∞ –∏ –∫—Ä–∞—Ç–∫–∞—è —Å—Ç—Ä–æ–∫–∞ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è). –ù–∏—á–µ–≥–æ –ª–∏—à–Ω–µ–≥–æ.
–í–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è:
"Quickstart Development
In order to write your first module, let's take a look at the basic structure:


from herokutl.types import Message
from .. import loader, utils


@loader.tds
class MyModule(loader.Module):
    """My module"""
    strings = {"name": "MyModule", "hello": "Hello world!"}
    strings_ru = {"hello": "–ü—Ä–∏–≤–µ—Ç –º–∏—Ä!"}
    strings_de = {"hello": "Hallo Welt!"}

    @loader.command(
        ru_doc="–ü—Ä–∏–≤–µ—Ç –º–∏—Ä!",
        de_doc="Hallo Welt!",
        # ...
    )
    async def helloworld(self, message: Message):
        """Hello world"""
        await utils.answer(message, self.strings["hello"])
    
The first line imports the Message type from herokutl.types and the loader module from ... The loader module contains all the necessary functions and classes to create a module.

@loader.tds is a decorator that makes module translateable (tds comes from translateable_docstring). In the class docstring you should specify brief information about the module so that user, that reads it can understand, what it does.

The strings dictionary is a special object, that contains translations for translateable strings. Suffix with desired language will allow user to use the module in the selected language. If there is no translation for the selected language, the default one will be used.

The @loader.command decorator is used to mark a function as a command. It takes a lot of arguments. Most important ones are translations. XX_doc makes description for command in the language XX.

utils.answer is an asyncronous function that answers the message. If it's possible to edit the message, it will edit it, otherwise it will send a new message. It always returns the resulted message so you can edit it again in the same command."

FormManager:
"# ¬©Ô∏è Dan Gazizullin, 2021-2023
# This file is a part of Hikka Userbot
# üåê https://github.com/hikariatama/Hikka
# You can redistribute it and/or modify it under the terms of the GNU AGPLv3
# üîë https://www.gnu.org/licenses/agpl-3.0.html

import contextlib
import copy
import logging
import os
import random
import time
import traceback
import typing
from asyncio import Event
from urllib.parse import urlparse

import grapheme
from aiogram.types import (
    InlineQuery,
    InlineQueryResultArticle,
    InlineQueryResultAudio,
    InlineQueryResultDocument,
    InlineQueryResultGif,
    InlineQueryResultLocation,
    InlineQueryResultPhoto,
    InlineQueryResultVideo,
    InputTextMessageContent,
)
from hikkatl.errors.rpcerrorlist import ChatSendInlineForbiddenError
from hikkatl.extensions.html import CUSTOM_EMOJIS
from hikkatl.tl.types import Message

from .. import main, utils
from ..types import HikkaReplyMarkup
from .types import InlineMessage, InlineUnit

logger = logging.getLogger(__name__)

VERIFICATION_EMOJIES = list(
    grapheme.graphemes(
        "üë®‚Äçüè´üë©‚Äçüè´üë®‚Äçüé§üßë‚Äçüé§üë©‚Äçüé§üë®‚Äçüéìüë©‚Äçüéìüë©‚Äçüç≥üë©‚Äçüåæüë©‚Äç‚öïÔ∏èüïµÔ∏è‚Äç‚ôÄÔ∏èüíÇ‚Äç‚ôÄÔ∏èüë∑‚Äç‚ôÇÔ∏èüëÆ‚Äç‚ôÇÔ∏èüë¥üßë‚Äçü¶≥üë©‚Äçü¶≥üë±‚Äç‚ôÄÔ∏èüë©‚Äçü¶∞üë®‚Äçü¶±üë©‚Äç‚öñÔ∏èüßô‚Äç‚ôÇÔ∏èüßù‚Äç‚ôÄÔ∏èüßõ‚Äç‚ôÄÔ∏è"
        "üéÖüßö‚Äç‚ôÇÔ∏èüôÜ‚Äç‚ôÄÔ∏èüôç‚Äç‚ôÇÔ∏èüë©‚Äçüë¶üß∂ü™¢ü™°üßµü©≤üëñüëïüëöü¶∫üëóüëôü©±üëòü•ªü©¥ü•øüß¶ü•æüëüüëû"
        "üë¢üë°üë†ü™ñüëëüíçüëùüëõüëúüíºüåÇü•Ωüï∂üëìüß≥üéíüê∂üê±üê≠üêπüê∞ü¶äüêªüê∑üêÆ"
        "ü¶ÅüêØüê®üêª‚Äç‚ùÑÔ∏èüêºüêΩüê∏üêµüôàüôâüôäüêíü¶Üüê•üê£üê§üê¶üêßüêîü¶Öü¶âü¶áüê∫üêóüê¥"
        "ü¶Ñüêúüêûüêåü¶ãüêõü™±üêùü™∞ü™≤ü™≥ü¶üü¶óüï∑üï∏üêôü¶ïü¶ñü¶éüêçüê¢ü¶Çü¶ëü¶êü¶û"
        "ü¶Äüê°üê†üêüüêÖüêäü¶≠ü¶àüêãüê≥üê¨üêÜü¶ìü¶çü¶ßü¶£üêòü¶õüêÉü¶¨ü¶òü¶íüê´üê™ü¶è"
        "üêÇüêÑüêéüêñüêèüêëü¶ôüêàüêï‚Äçü¶∫ü¶Æüê©üêïü¶åüêêüêà‚Äç‚¨õü™∂üêìü¶Éü¶§ü¶öü¶úü¶°ü¶®ü¶ùüêá"
        "üïäü¶©ü¶¢ü¶´ü¶¶ü¶•üêÅüêÄüêøü¶îüå≥üå≤üåµüê≤üêâüêæüéãüçÇüçÅüçÑüêöüåæü™®üíêüå∑"
        "ü•Äüå∫üå∏üåªüåûüåúüåòüåóüåéü™êüí´‚≠êÔ∏è‚ú®‚ö°Ô∏è‚òÑÔ∏èüí•‚òÄÔ∏èüå™üî•üåàüå§‚õÖÔ∏è‚ùÑÔ∏è‚õÑÔ∏èüåä"
        "‚òÇÔ∏èüçèüçéüçêüçäüçãüçåüçâü•≠üçëüçíüçàü´êüçìüçáüççü••ü•ùüçÖü•ëü•¶üßî‚Äç‚ôÇÔ∏è"
    )
)


class Placeholder:
    """Placeholder"""


class Form(InlineUnit):
    async def form(
        self,
        text: str,
        message: typing.Union[Message, int],
        reply_markup: typing.Optional[HikkaReplyMarkup] = None,
        *,
        force_me: bool = False,
        always_allow: typing.Optional[typing.List[int]] = None,
        manual_security: bool = False,
        disable_security: bool = False,
        ttl: typing.Optional[int] = None,
        on_unload: typing.Optional[callable] = None,
        photo: typing.Optional[str] = None,
        gif: typing.Optional[str] = None,
        file: typing.Optional[str] = None,
        mime_type: typing.Optional[str] = None,
        video: typing.Optional[str] = None,
        location: typing.Optional[str] = None,
        audio: typing.Optional[typing.Union[dict, str]] = None,
        silent: bool = False,
    ) -> typing.Union[InlineMessage, bool]:
        """
        Send inline form to chat
        :param text: Content of inline form. HTML markdown supported
        :param message: Where to send inline. Can be either `Message` or `int`
        :param reply_markup: List of buttons to insert in markup. List of dicts with keys: text, callback
        :param force_me: Either this form buttons must be pressed only by owner scope or no
        :param always_allow: Users, that are allowed to press buttons in addition to previous rules
        :param ttl: Time, when the form is going to be unloaded. Unload means, that the form
                    buttons with inline queries and callback queries will become unusable, but
                    buttons with type url will still work as usual. Pay attention, that ttl can't
                    be bigger, than default one (1 day) and must be either `int` or `False`
        :param on_unload: Callback, called when form is unloaded and/or closed. You can clean up trash
                          or perform another needed action
        :param manual_security: By default, Hikka will try to inherit inline buttons security from the caller (command)
                                If you want to avoid this, pass `manual_security=True`
        :param disable_security: By default, Hikka will try to inherit inline buttons security from the caller (command)
                                 If you want to disable all security checks on this form in particular, pass `disable_security=True`
        :param photo: Attach a photo to the form. URL must be supplied
        :param gif: Attach a gif to the form. URL must be supplied
        :param file: Attach a file to the form. URL must be supplied
        :param mime_type: Only needed, if `file` field is not empty. Must be either 'application/pdf' or 'application/zip'
        :param video: Attach a video to the form. URL must be supplied
        :param location: Attach a map point to the form. List/tuple must be supplied (latitude, longitude)
                         Example: (55.749931, 48.742371)
                         ‚ö†Ô∏è If you pass this parameter, you'll need to pass empty string to `text` ‚ö†Ô∏è
        :param audio: Attach a audio to the form. Dict or URL must be supplied
        :param silent: Whether the form must be sent silently (w/o "Opening form..." message)
        :return: If form is sent, returns :obj:`InlineMessage`, otherwise returns `False`
        """
        with contextlib.suppress(AttributeError):
            _hikka_client_id_logging_tag = copy.copy(self._client.tg_id)  # noqa: F841

        if reply_markup is None:
            reply_markup = []

        if always_allow is None:
            always_allow = []

        if not isinstance(text, str):
            logger.error(
                "Invalid type for `text`. Expected `str`, got `%s`",
                type(text),
            )
            return False

        text = self.sanitise_text(text)

        if not isinstance(silent, bool):
            logger.error(
                "Invalid type for `silent`. Expected `bool`, got `%s`",
                type(silent),
            )
            return False

        if not isinstance(manual_security, bool):
            logger.error(
                "Invalid type for `manual_security`. Expected `bool`, got `%s`",
                type(manual_security),
            )
            return False

        if not isinstance(disable_security, bool):
            logger.error(
                "Invalid type for `disable_security`. Expected `bool`, got `%s`",
                type(disable_security),
            )
            return False

        if not isinstance(message, (Message, int)):
            logger.error(
                "Invalid type for `message`. Expected `Message` or `int`, got `%s`",
                type(message),
            )
            return False

        if not isinstance(reply_markup, (list, dict)):
            logger.error(
                "Invalid type for `reply_markup`. Expected `list` or `dict`, got `%s`",
                type(reply_markup),
            )
            return False

        if photo and (not isinstance(photo, str) or not utils.check_url(photo)):
            logger.error(
                "Invalid type for `photo`. Expected `str` with URL, got `%s`",
                type(photo),
            )
            return False

        try:
            path = urlparse(photo).path
            ext = os.path.splitext(path)[1]
        except Exception:
            ext = None

        if photo is not None and ext in {".gif", ".mp4"}:
            gif = copy.copy(photo)
            photo = None

        if gif and (not isinstance(gif, str) or not utils.check_url(gif)):
            logger.error(
                "Invalid type for `gif`. Expected `str` with URL, got `%s`",
                type(gif),
            )
            return False

        if file and (not isinstance(file, str) or not utils.check_url(file)):
            logger.error(
                "Invalid type for `file`. Expected `str` with URL, got `%s`",
                type(file),
            )
            return False

        if file and not mime_type:
            logger.error(
                "You must pass `mime_type` along with `file` field\n"
                "It may be either 'application/zip' or 'application/pdf'"
            )
            return False

        if video and (not isinstance(video, str) or not utils.check_url(video)):
            logger.error(
                "Invalid type for `video`. Expected `str` with URL, got `%s`",
                type(video),
            )
            return False

        if isinstance(audio, str):
            audio = {"url": audio}

        if audio and (
            not isinstance(audio, dict)
            or "url" not in audio
            or not utils.check_url(audio["url"])
        ):
            logger.error(
                "Invalid type for `audio`. Expected `dict` with `url` key, got `%s`",
                type(audio),
            )
            return False

        if location and (
            not isinstance(location, (list, tuple))
            or len(location) != 2
            or not all(isinstance(item, float) for item in location)
        ):
            logger.error(
                (
                    "Invalid type for `location`. Expected `list` or `tuple` with 2"
                    " `float` items, got `%s`"
                ),
                type(location),
            )
            return False

        if [
            photo is not None,
            gif is not None,
            file is not None,
            video is not None,
            audio is not None,
            location is not None,
        ].count(True) > 1:
            logger.error("You passed two or more exclusive parameters simultaneously")
            return False

        reply_markup = self._validate_markup(reply_markup) or []

        if not isinstance(force_me, bool):
            logger.error(
                "Invalid type for `force_me`. Expected `bool`, got `%s`",
                type(force_me),
            )
            return False

        if not isinstance(always_allow, list):
            logger.error(
                "Invalid type for `always_allow`. Expected `list`, got `%s`",
                type(always_allow),
            )
            return False

        if not isinstance(ttl, int) and ttl:
            logger.error("Invalid type for `ttl`. Expected `int`, got `%s`", type(ttl))
            return False

        if isinstance(message, Message) and not silent:
            try:
                status_message = await (
                    message.edit if message.out else message.respond
                )(
                    (
                        utils.get_platform_emoji()
                        if self._client.hikka_me.premium and CUSTOM_EMOJIS
                        else "üåò"
                    )
                    + self.translator.getkey("inline.opening_form"),
                    **({"reply_to": utils.get_topic(message)} if message.out else {}),
                )
            except Exception:
                status_message = None
        else:
            status_message = None

        unit_id = utils.rand(16)

        perms_map = None if manual_security else self._find_caller_sec_map()

        if not reply_markup and not ttl:
            logger.debug("Patching form reply markup with empty data")
            base_reply_markup = copy.deepcopy(reply_markup) or None
            reply_markup = self._validate_markup({"text": "¬≠", "data": "¬≠"})
        else:
            base_reply_markup = Placeholder()

        if (
            not any(
                any("callback" in button or "input" in button for button in row)
                for row in reply_markup
            )
            and not ttl
        ):
            logger.debug(
                "Patching form ttl to 10 minutes, because it doesn't contain any"
                " buttons"
            )
            ttl = 10 * 60

        self._units[unit_id] = {
            "type": "form",
            "text": text,
            "buttons": reply_markup,
            "caller": message,
            "chat": None,
            "message_id": None,
            "top_msg_id": utils.get_topic(message),
            "uid": unit_id,
            "on_unload": on_unload,
            "future": Event(),
            **({"photo": photo} if photo else {}),
            **({"video": video} if video else {}),
            **({"gif": gif} if gif else {}),
            **({"location": location} if location else {}),
            **({"audio": audio} if audio else {}),
            **({"location": location} if location else {}),
            **({"perms_map": perms_map} if perms_map else {}),
            **({"message": message} if isinstance(message, Message) else {}),
            **({"force_me": force_me} if force_me else {}),
            **({"disable_security": disable_security} if disable_security else {}),
            **({"ttl": round(time.time()) + ttl} if ttl else {}),
            **({"always_allow": always_allow} if always_allow else {}),
        }

        async def answer(msg: str):
            nonlocal message
            if isinstance(message, Message):
                await (message.edit if message.out else message.respond)(
                    msg,
                    **({} if message.out else {"reply_to": utils.get_topic(message)}),
                )
            else:
                await self._client.send_message(message, msg)

        try:
            m = await self._invoke_unit(unit_id, message)
        except ChatSendInlineForbiddenError:
            await answer(self.translator.getkey("inline.inline403"))
        except Exception:
            logger.exception("Can't send form")

            del self._units[unit_id]
            await answer(
                self.translator.getkey("inline.invoke_failed_logs").format(
                    utils.escape_html(
                        "\n".join(traceback.format_exc().splitlines()[1:])
                    )
                )
                if self._db.get(main.__name__, "inlinelogs", True)
                else self.translator.getkey("inline.invoke_failed")
            )

            return False

        await self._units[unit_id]["future"].wait()
        del self._units[unit_id]["future"]

        self._units[unit_id]["chat"] = utils.get_chat_id(m)
        self._units[unit_id]["message_id"] = m.id

        if isinstance(message, Message) and message.out:
            await message.delete()

        if status_message and not message.out:
            await status_message.delete()

        inline_message_id = self._units[unit_id]["inline_message_id"]

        msg = InlineMessage(self, unit_id, inline_message_id)

        if not isinstance(base_reply_markup, Placeholder):
            await msg.edit(text, reply_markup=base_reply_markup)

        return msg

    async def _form_inline_handler(self, inline_query: InlineQuery):
        try:
            query = inline_query.query.split()[0]
        except IndexError:
            return

        for unit in self._units.copy().values():
            for button in utils.array_sum(unit.get("buttons", [])):
                if (
                    "_switch_query" in button
                    and "input" in button
                    and button["_switch_query"] == query
                    and inline_query.from_user.id
                    in [self._me]
                    + self._client.dispatcher.security._owner
                    + unit.get("always_allow", [])
                ):
                    await inline_query.answer(
                        [
                            InlineQueryResultArticle(
                                id=utils.rand(20),
                                title=button["input"],
                                description=(
                                    self.translator.getkey("inline.keep_id").format(
                                        random.choice(VERIFICATION_EMOJIES)
                                    )
                                ),
                                input_message_content=InputTextMessageContent(
                                    (
                                        "üîÑ <b>Transferring value to"
                                        " userbot...</b>\n<i>This message will be"
                                        " deleted automatically</i>"
                                        if inline_query.from_user.id == self._me
                                        else "üîÑ <b>Transferring value to userbot...</b>"
                                    ),
                                    "HTML",
                                    disable_web_page_preview=True,
                                ),
                            )
                        ],
                        cache_time=60,
                    )
                    return

        if (
            inline_query.query not in self._units
            or self._units[inline_query.query]["type"] != "form"
        ):
            return

        form = self._units[inline_query.query]
        try:
            if "photo" in form:
                await inline_query.answer(
                    [
                        InlineQueryResultPhoto(
                            id=utils.rand(20),
                            title="Hikka",
                            description="Hikka",
                            caption=form.get("text"),
                            parse_mode="HTML",
                            photo_url=form["photo"],
                            thumb_url=(
                                "https://img.icons8.com/cotton/452/moon-satellite.png"
                            ),
                            reply_markup=self.generate_markup(
                                form["uid"],
                            ),
                        )
                    ],
                    cache_time=0,
                )
            elif "gif" in form:
                await inline_query.answer(
                    [
                        InlineQueryResultGif(
                            id=utils.rand(20),
                            title="Hikka",
                            caption=form.get("text"),
                            parse_mode="HTML",
                            gif_url=form["gif"],
                            thumb_url=(
                                "https://img.icons8.com/cotton/452/moon-satellite.png"
                            ),
                            reply_markup=self.generate_markup(
                                form["uid"],
                            ),
                        )
                    ],
                    cache_time=0,
                )
            elif "video" in form:
                await inline_query.answer(
                    [
                        InlineQueryResultVideo(
                            id=utils.rand(20),
                            title="Hikka",
                            description="Hikka",
                            caption=form.get("text"),
                            parse_mode="HTML",
                            video_url=form["video"],
                            thumb_url=(
                                "https://img.icons8.com/cotton/452/moon-satellite.png"
                            ),
                            mime_type="video/mp4",
                            reply_markup=self.generate_markup(
                                form["uid"],
                            ),
                        )
                    ],
                    cache_time=0,
                )
            elif "file" in form:
                await inline_query.answer(
                    [
                        InlineQueryResultDocument(
                            id=utils.rand(20),
                            title="Hikka",
                            description="Hikka",
                            caption=form.get("text"),
                            parse_mode="HTML",
                            document_url=form["file"],
                            mime_type=form["mime_type"],
                            reply_markup=self.generate_markup(
                                form["uid"],
                            ),
                        )
                    ],
                    cache_time=0,
                )
            elif "location" in form:
                await inline_query.answer(
                    [
                        InlineQueryResultLocation(
                            id=utils.rand(20),
                            latitude=form["location"][0],
                            longitude=form["location"][1],
                            title="Hikka",
                            reply_markup=self.generate_markup(
                                form["uid"],
                            ),
                        )
                    ],
                    cache_time=0,
                )
            elif "audio" in form:
                await inline_query.answer(
                    [
                        InlineQueryResultAudio(
                            id=utils.rand(20),
                            audio_url=form["audio"]["url"],
                            caption=form.get("text"),
                            parse_mode="HTML",
                            title=form["audio"].get("title", "Hikka"),
                            performer=form["audio"].get("performer"),
                            audio_duration=form["audio"].get("duration"),
                            reply_markup=self.generate_markup(
                                form["uid"],
                            ),
                        )
                    ],
                    cache_time=0,
                )
            else:
                await inline_query.answer(
                    [
                        InlineQueryResultArticle(
                            id=utils.rand(20),
                            title="Hikka",
                            input_message_content=InputTextMessageContent(
                                form["text"],
                                "HTML",
                                disable_web_page_preview=True,
                            ),
                            reply_markup=self.generate_markup(inline_query.query),
                        )
                    ],
                    cache_time=0,
                )
        except Exception as e:
            if form["uid"] in self._error_events:
                self._error_events[form["uid"]].set()
                self._error_events[form["uid"]] = e"


                "Inline
Dan Gazizullin edited this page on Jul 13, 2022 ¬∑ 1 revision
Form
To create message buttons, use form manager:

Reference:
async def form(
    self,
    text: str,
    message: Union[Message, int],
    reply_markup: Union[List[List[dict]], List[dict], dict] = None,
    *,
    force_me: Optional[bool] = False,
    always_allow: Optional[List[list]] = None,
    manual_security: Optional[bool] = False,
    disable_security: Optional[bool] = False,
    ttl: Optional[int] = None,
    on_unload: Optional[callable] = None,
    photo: Optional[str] = None,
    gif: Optional[str] = None,
    file: Optional[str] = None,
    mime_type: Optional[str] = None,
    video: Optional[str] = None,
    location: Optional[str] = None,
    audio: Optional[Union[dict, str]] = None,
    silent: Optional[bool] = False,
) -> Union[InlineMessage, bool]:
    """
    Send inline form to chat
    :param text: Content of inline form. HTML markdown supported
    :param message: Where to send inline. Can be either `Message` or `int`
    :param reply_markup: List of buttons to insert in markup. List of dicts with keys: text, callback
    :param force_me: Either this form buttons must be pressed only by owner scope or no
    :param always_allow: Users, that are allowed to press buttons in addition to previous rules
    :param ttl: Time, when the form is going to be unloaded. Unload means, that the form
                buttons with inline queries and callback queries will become unusable, but
                buttons with type url will still work as usual. Pay attention, that ttl can't
                be bigger, than default one (1 day) and must be either `int` or `False`
    :param on_unload: Callback, called when form is unloaded and/or closed. You can clean up trash
                        or perform another needed action
    :param manual_security: By default, Hikka will try to inherit inline buttons security from the caller (command)
                            If you want to avoid this, pass `manual_security=True`
    :param disable_security: By default, Hikka will try to inherit inline buttons security from the caller (command)
                                If you want to disable all security checks on this form in particular, pass `disable_security=True`
    :param photo: Attach a photo to the form. URL must be supplied
    :param gif: Attach a gif to the form. URL must be supplied
    :param file: Attach a file to the form. URL must be supplied
    :param mime_type: Only needed, if `file` field is not empty. Must be either 'application/pdf' or 'application/zip'
    :param video: Attach a video to the form. URL must be supplied
    :param location: Attach a map point to the form. List/tuple must be supplied (latitude, longitude)
                        Example: (55.749931, 48.742371)
                        ‚ö†Ô∏è If you pass this parameter, you'll need to pass empty string to `text` ‚ö†Ô∏è
    :param audio: Attach a audio to the form. Dict or URL must be supplied
    :param silent: Whether the form must be sent silently (w/o "Loading inline form..." message)
    :return: If form is sent, returns :obj:`InlineMessage`, otherwise returns `False`
    """
Example:
await self.inline.form(
    text="üìä Poll Hikka vs. FTG\nüåò Hikka: No votes\nüòî FTG: No votes",
    message=message,
    reply_markup=[
        [
            {
                "text": "Hikka",
                "callback": self.vote,
                "args": [False]
            }
        ],
        [
            {
                "text": "FTG",
                "callback": self.vote,
                "args": [True]
            }
        ],
    ],
    force_me=False,  # optional: Allow other users to access form (all)
    always_allow=[659800858],  # optional: Permit users with IDs
    ttl=30,  # optional: Time to live of form in seconds
    silent=True,  # optional: Send form silently
)
–ë–µ–∑ –∏–º–µ–Ω–∏-1

Buttons examples:

Button with function callback (most frequently used):
{
    "text": "Button with function",
    "callback": self.callback_handler,
    "args": (arg1, ),  # optional arguments passed to callback
    "kwargs": {"arg1name": "arg1"},  # optional kwargs passed to callback
}
Button with custom payload (button_callback_handler):
{
    "text": "Button with custom payload",
    "data": "custom_payload",
}
Button with link:
{
    "text": "URL Button",
    "url": "https://example.com",
}
Button which asks user to input some value:
{
    "text": "‚úçÔ∏è Enter value",
    "input": "‚úçÔ∏è Enter new configuration value for this option",
    "handler": self.input_handler,
    "args": (arg1, ),  # optional arguments passed to callback
    "kwargs": {"arg1name": "arg1"},  # optional kwargs passed to callback
}
Button with pre-defined action:
{
    "text": "Close form",
    "action": "close",
}
{
    "text": "Unload form",
    "action": "unload",
}
{
    "text": "Say `Thank you!`",
    "action": "answer",
    "text": "Thank you!",
}
‚ö†Ô∏è If error occurs, no exception will be raised, only False returned !

Gallery
There are inline galleries

Reference:
async def gallery(
    self,
    message: Union[Message, int],
    next_handler: Union[callable, List[str]],
    caption: Optional[Union[List[str], str, callable]] = "",
    *,
    custom_buttons: Optional[Union[List[List[dict]], List[dict], dict]] = None,
    force_me: Optional[bool] = False,
    always_allow: Optional[list] = None,
    manual_security: Optional[bool] = False,
    disable_security: Optional[bool] = False,
    ttl: Optional[Union[int, bool]] = False,
    on_unload: Optional[callable] = None,
    preload: Optional[Union[bool, int]] = False,
    gif: Optional[bool] = False,
    silent: Optional[bool] = False,
    _reattempt: bool = False,
) -> Union[bool, InlineMessage]:
    """
    Send inline gallery to chat
    :param caption: Caption for photo, or callable, returning caption
    :param message: Where to send inline. Can be either `Message` or `int`
    :param next_handler: Callback function, which must return url for next photo or list with photo urls
    :param custom_buttons: Custom buttons to add above native ones
    :param force_me: Either this gallery buttons must be pressed only by owner scope or no
    :param always_allow: Users, that are allowed to press buttons in addition to previous rules
    :param ttl: Time, when the gallery is going to be unloaded. Unload means, that the gallery
                will become unusable. Pay attention, that ttl can't
                be bigger, than default one (1 day) and must be either `int` or `False`
    :param on_unload: Callback, called when gallery is unloaded and/or closed. You can clean up trash
                        or perform another needed action
    :param preload: Either to preload gallery photos beforehand or no. If yes - specify threshold to
                    be loaded. Toggle this attribute, if your callback is too slow to load photos
                    in real time
    :param gif: Whether the gallery will be filled with gifs. If you omit this argument and specify
                gifs in `next_handler`, Hikka will try to determine the filetype of these images
    :param manual_security: By default, Hikka will try to inherit inline buttons security from the caller (command)
                            If you want to avoid this, pass `manual_security=True`
    :param disable_security: By default, Hikka will try to inherit inline buttons security from the caller (command)
                                If you want to disable all security checks on this gallery in particular, pass `disable_security=True`
    :param silent: Whether the gallery must be sent silently (w/o "Loading inline gallery..." message)
    :return: If gallery is sent, returns :obj:`InlineMessage`, otherwise returns `False`
    """
Example
def generate_caption() -> str:
    return random.choice(["–î–∞", "–ù–µ—Ç"])

async def photo() -> str:
    return (await utils.run_sync(requests.get, "https://api.catboys.com/img")).json()["url"]

await self.inline.gallery(
    message=message,
    next_handler=photo,
    caption=generate_caption,
)
generate_caption - method, which returns caption photo - Async function, which returns photo(-s)

Instead of generate_caption you can pass string or list Instead of photo you can pass list with urls"

built-in method:"# ¬©Ô∏è Dan Gazizullin, 2021-2023
# This file is a part of Hikka Userbot
# üåê https://github.com/hikariatama/Hikka
# You can redistribute it and/or modify it under the terms of the GNU AGPLv3
# üîë https://www.gnu.org/licenses/agpl-3.0.html

import asyncio
import logging
import time
import typing

from aiogram.types import InlineQuery, InlineQueryResultArticle, InputTextMessageContent

from .. import utils
from .types import InlineUnit

logger = logging.getLogger(__name__)


class QueryGallery(InlineUnit):
    async def query_gallery(
        self,
        query: InlineQuery,
        items: typing.List[typing.Dict[str, typing.Any]],
        *,
        force_me: bool = False,
        disable_security: bool = False,
        always_allow: typing.Optional[typing.List[int]] = None,
    ) -> bool:
        """
        Answer inline query with a bunch of inline galleries
        :param query: `InlineQuery` which should be answered with inline gallery
        :param items: Array of dicts with inline results.
                      Each dict *must* has a:
                          - `title` - The title of the result
                          - `description` - Short description of the result
                          - `next_handler` - Inline gallery handler. Callback or awaitable
                      Each dict *can* has a:
                          - `caption` - Caption of photo. Defaults to `""`
                          - `force_me` - Whether the button must be accessed only by owner. Defaults to `False`
                          - `disable_security` - Whether to disable the security checks at all. Defaults to `False`
        :param force_me: Either this gallery buttons must be pressed only by owner scope or no
        :param always_allow: Users, that are allowed to press buttons in addition to previous rules
        :param disable_security: By default, Hikka will try to check security of gallery
                                 If you want to disable all security checks on this gallery in particular, pass `disable_security=True`
        :return: Status of answer
        """
        if not isinstance(force_me, bool):
            logger.error(
                "Invalid type for `force_me`. Expected `bool`, got %s",
                type(force_me),
            )
            return False

        if not isinstance(disable_security, bool):
            logger.error(
                "Invalid type for `disable_security`. Expected `bool`, got %s",
                type(disable_security),
            )
            return False

        if always_allow and not isinstance(always_allow, list):
            logger.error(
                "Invalid type for `always_allow`. Expected `list`, got %s",
                type(always_allow),
            )
            return False

        if not always_allow:
            always_allow = []

        if (
            not isinstance(items, list)
            or not all(isinstance(i, dict) for i in items)
            or not all(
                "title" in i
                and "description" in i
                and "next_handler" in i
                and (
                    callable(i["next_handler"])
                    or asyncio.iscoroutinefunction(i)
                    or isinstance(i, list)
                )
                and isinstance(i["title"], str)
                and isinstance(i["description"], str)
                for i in items
            )
        ):
            logger.error("Invalid `items` specified in query gallery")
            return False

        result = []
        for i in items:
            if "thumb_handler" not in i:
                photo_url = await self._call_photo(i["next_handler"])
                if not photo_url:
                    return False

                if isinstance(photo_url, list):
                    photo_url = photo_url[0]

                if not isinstance(photo_url, str):
                    logger.error(
                        "Invalid result from `next_handler`. Expected `str`, got %s",
                        type(photo_url),
                    )
                    continue
            else:
                photo_url = await self._call_photo(i["thumb_handler"])
                if not photo_url:
                    return False

                if isinstance(photo_url, list):
                    photo_url = photo_url[0]

                if not isinstance(photo_url, str):
                    logger.error(
                        "Invalid result from `thumb_handler`. Expected `str`, got %s",
                        type(photo_url),
                    )
                    continue

            id_ = utils.rand(16)

            self._custom_map[id_] = {
                "handler": i["next_handler"],
                "ttl": round(time.time()) + 120,
                **({"always_allow": always_allow} if always_allow else {}),
                **({"force_me": force_me} if force_me else {}),
                **({"disable_security": disable_security} if disable_security else {}),
                **({"caption": i["caption"]} if "caption" in i else {}),
            }

            result += [
                InlineQueryResultArticle(
                    id=utils.rand(20),
                    title=i["title"],
                    description=i["description"],
                    input_message_content=InputTextMessageContent(
                        f"üåò <b>Opening gallery...</b>\n<i>#id: {id_}</i>",
                        "HTML",
                        disable_web_page_preview=True,
                    ),
                    thumb_url=photo_url,
                    thumb_width=128,
                    thumb_height=128,
                )
            ]

        await query.answer(result, cache_time=0)
        return True"

        "InlineQuery Galleries
To allow user to call galleries via inline query (@hikka_xxxxxx_bot), use built-in method

Reference:
async def query_gallery(
    self,
    query: InlineQuery,
    items: List[dict],
    *,
    force_me: Optional[bool] = False,
    disable_security: Optional[bool] = False,
    always_allow: Optional[list] = None,
) -> bool:
    """
    Answer inline query with a bunch of inline galleries
    :param query: `InlineQuery` which should be answered with inline gallery
    :param items: Array of dicts with inline results.
                    Each dict *must* has a:
                        - `title` - The title of the result
                        - `description` - Short description of the result
                        - `next_handler` - Inline gallery handler. Callback or awaitable
                    Each dict *can* has a:
                        - `caption` - Caption of photo. Defaults to `""`
                        - `force_me` - Whether the button must be accessed only by owner. Defaults to `False`
                        - `disable_security` - Whether to disable the security checks at all. Defaults to `False`
    :param force_me: Either this gallery buttons must be pressed only by owner scope or no
    :param always_allow: Users, that are allowed to press buttons in addition to previous rules
    :param disable_security: By default, Hikka will try to check security of gallery
                                If you want to disable all security checks on this gallery in particular, pass `disable_security=True`
    :return: Status of answer
    """
Example
async def catboy_inline_handler(self, query: InlineQuery):
    """Send Catboys"""
    await self.inline.query_gallery(
        query,
        [
            {
                "title": "üåò Catboy",
                "description": "Send catboy photo",
                "next_handler": photo,
                "thumb_handler": photo,  # Optional
                "caption": lambda: f"<i>Enjoy! {utils.escape_html(utils.ascii_face())}</i>",  # Optional
                # Because of ^ this lambda, face will be generated every time the photo is switched

                # "caption": f"<i>Enjoy! {utils.escape_html(utils.ascii_face())}</i>",
                # If you make it without lambda ^, it will be generated once
            }
        ],
    )
List
You can use inline lists

Reference:
async def list(
    self,
    message: Union[Message, int],
    strings: _List[str],
    *,
    force_me: Optional[bool] = False,
    always_allow: Optional[list] = None,
    manual_security: Optional[bool] = False,
    disable_security: Optional[bool] = False,
    ttl: Optional[Union[int, bool]] = False,
    on_unload: Optional[callable] = None,
    silent: Optional[bool] = False,
    custom_buttons: Optional[Union[_List[_List[dict]], _List[dict], dict]] = None,
) -> Union[bool, InlineMessage]:
    """
    Send inline list to chat
    :param message: Where to send list. Can be either `Message` or `int`
    :param strings: List of strings, which should become inline list
    :param force_me: Either this list buttons must be pressed only by owner scope or no
    :param always_allow: Users, that are allowed to press buttons in addition to previous rules
    :param ttl: Time, when the list is going to be unloaded. Unload means, that the list
                will become unusable. Pay attention, that ttl can't
                be bigger, than default one (1 day) and must be either `int` or `False`
    :param on_unload: Callback, called when list is unloaded and/or closed. You can clean up trash
                        or perform another needed action
    :param manual_security: By default, Hikka will try to inherit inline buttons security from the caller (command)
                            If you want to avoid this, pass `manual_security=True`
    :param disable_security: By default, Hikka will try to inherit inline buttons security from the caller (command)
                                If you want to disable all security checks on this list in particular, pass `disable_security=True`
    :param silent: Whether the list must be sent silently (w/o "Loading inline list..." message)
    :param custom_buttons: Custom buttons to add above native ones
    :return: If list is sent, returns :obj:`InlineMessage`, otherwise returns `False`
    """
Example
async def meancmd(self, message: Message):
    """<term> - Find definition of the word in urban dictionary"""
    args = utils.get_args_raw(message)

    ...

    await self.inline.list(
        message,
        [self.strings("meaning").format(args, mean) for mean in means],
    )
Inline buttons processing
Example, where along with callback 1 positional argument is passed

from ..inline.types import InlineCall
async def _process_click_ai(self, call: InlineCall, arg1: str):
    # Do some stuff
In this case you can also use:

await call.unload()  # Unload form from memory

await call.delete()  # Unload form from memory and delete message

await call.edit(
    text="Some new text",
    reply_markup=[
        [
            {
                "text": "New Button",
                "url": "https://ya.ru"
            }
        ]
    ],  # optional: Change buttons in message. If not specified, buttons will be removed
    disable_web_page_preview=True,  # optional: Disable link preview
    always_allow=[659800858],  # optional: Change allowed users
    force_me=False,  # optional: Change button privacy mode
)

call.form  # optional: Contains info about form
Inline (@bot ...)
from ..inline.types import InlineQuery

async def <name>_inline_handler(self, query: InlineQuery):
    # Process request
To get text, entered after the call, use query.args You can wrap these handlers with:

@loader.support
@loader.sudo
@loader.owner
@loader.inline_everyone
Useful shortcuts
await query.e400() - –ù–µ–≤–µ—Ä–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
await query.e403() - –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ä–µ—Å—É—Ä—Å—É
await query.e404() - –¢—Ä–µ–±—É–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
await query.e426() - –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —é–∑–µ—Ä–±–æ—Ç–∞
await query.e500() - –û—à–∏–±–∫–∞ –º–æ–¥—É–ª—è. –°–º–æ—Ç—Ä–∏ –ª–æ–≥–∏
Inline query
You need to return dictionary with answer:

{"message": "<b>Message text</b>", "title": "Text answer"}
{"photo": "https://i.imgur.com/hZIyI7v.jpeg", "title": "Photo"}
{"video": "https://x0.at/wWN9.mp4", "title": "Video"}
{"file": "https://x0.at/f7ps.pdf", "mime_type": "application/pdf", "title": "Document"}
{"gif": "https://x0.at/Sey-.mp4", "title": "GIF animation"}"

"Libraries
Dan Gazizullin edited this page on Aug 13, 2022 ¬∑ 4 revisions
Libraries
If you have a code, which is used in several modules, you can pack it in library and then import it everywhere you need.
There's separate config design for shared libraries.
‚ö†Ô∏è Libraries are available only starting from Hikka v1.2.10. If you use anything listed below, make sure you have a # scope: hikka_min 1.2.10(–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ,—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø—Ä–æ—Å—è—Ç)

Example:
https://libs.hikariatama.ru/musicdl.py:

from .. import loader, utils
import telethon
import asyncio
import logging


class MusicDL_Lib(loader.Library):
    developer = "@hikariatama"

    async def dl(self, full_name: str) -> bytes:
        try:
            q = await self._client.inline_query("@losslessrobot", full_name)
            result = q.result.results[0]
            if not getattr(getattr(result, "send_message", None), "reply_markup", None):
                dl_file = result.document
            else:
                m = await q[0].click("me")

                dl_event = asyncio.Event()
                dl_file = None

                @self._client.on(
                    telethon.events.MessageEdited(chats=utils.get_chat_id(m))
                )
                async def handler(event: telethon.events.MessageEdited):
                    nonlocal dl_file
                    if (
                        event.message.id == m.id
                        and not getattr(event.message, "reply_markup", None)
                        and event.message.document
                    ):
                        dl_file = event.message.document
                        dl_event.set()
                        raise telethon.events.StopPropagation

                try:
                    await asyncio.wait_for(dl_event.wait(), timeout=40)
                except Exception:
                    await m.delete()
                    raise

            async with self._client.conversation("@DirectLinkGenerator_Bot") as conv:
                m = await conv.send_file(dl_file)
                r = await conv.get_response()
                await m.delete()
                await r.delete()
                return r.reply_markup.rows[0].buttons[1].url
        except Exception:
            logging.exception("Can't download")
            return None
Detailed info about library structure:
https://libs.hikariatama.ru/example.py:

# -----------------------------------------------------------------------------
# This is example library code
# ‚ö†Ô∏è Any scopes, specified there will be ignored, including # requires:
# requires: example_pypi_package - THIS LINE DOES NOTHING

from .. import loader
import random
import logging

# Every library class name must end with `Lib` and be subclass of `loader.Library`
#            üëá         üëá
class ExampleLib(loader.Library):
    # You can specify the developer of library in this way:
    developer = "@hikariatama"

    # Declare library config in `__init__`:

    def __init__(self):
        # loader.ModuleConfig will throw!
        self.config = loader.LibraryConfig(
            loader.ConfigValue(
                "example_option",
                "default",
                "Example description",
                validator=loader.validators.String(),
            )
        )

    async def init(self):
        ...  # Do some stuff for init

    # ----------------------------------------------

    # ----------------------------------------------
    # Methods may be async or sync:
    def example_method(self) -> str:
        # self._client and self._db are available
        # No need to explicitly import them
        return (
            "anime neko "
            + random.choice(["girl", "boy"])
            + " --> "
            + self._client._tg_id
        )

    async def example_async(self):
        await self._client.send_message("me", "Hello!")

    # ----------------------------------------------


# --------------------------------------------------------------
# Then in your module code you can access this library in this way:

async def client_ready(self, client, db):
    ...
    self.example = await self.import_lib("https://link.to.your.server/example.py")

    logging.info(self.example.example_method())
    await self.example.example_async()


# If library throws an error, or is unavailable (404\403 etc),
# module will be UNLOADED FROM DB and will not be loaded again
# If you want to avoid this, use example below, or handle errors
# in your module code:


async def client_ready(self, client, db):
    try:
        self.example = await self.import_lib(...)
    except Exception:
        self.example = None

    if self.example:
        self.example.example_method()
    else:
        logging.warning("Library is not available along with method from it")


# --------------------------------------------------------------
# If you don't handle errors while importing (see example above), use `suspend_on_error` param
# to import the library:


async def client_ready(self, client, db):
    ...
    self.example = await self.import_lib(
        "https://link.to.your.server/example.py",
        suspend_on_error=True,  # üëàüëàüëàüëàüëàüëàüëàüëàüëàüëàüëàüëàüëàüëàüëà
    )

    logging.info(self.example.example_method())
    await self.example.example_async()


# This way, if Hikka can't load library, it'll suspend your module
# It won't be unloaded from db, so user will get it after restart, if
# library becomes available

# --------------------------------------------------------------"

"Quickstart
Dan Gazizullin edited this page on Jul 13, 2022 ¬∑ 1 revision
Basic sctructure
Any module starts with:

License
Scopes
Dependencies import
Logging init
Module class, wrapped with @loader.tds
Declaring basic handlers
All other actions live in module class*.

*Notice. If method doesn't use self (self.anything), it should be declared as static except of commands, watchers and other stuff, used by Hikka under the hood

Structure docs
def __init__(self):
Used only for config definition

async def client_ready(self, client, db):
It's called when module is inited. Frequently used to start handlers, init APIs etc.

async def on_dlmod(self, client, db):
It's called when module is installed. Frequently used to collect stats, join required channels.

async def on_unload(self):
It's called when module is being unloaded. Here you can stop loops, exit APIs etc.

async def testcmd(self, message: Message):
Handler of command. Any method, which ends with cmd will be considered as command

async def watcher(self, message: Message):
All messages handler. All message events trigger this, including service messages

utils.py
For utils docs, read the source code with comments and docstrings: utils.py

strings
This is not a dictionary. Used in translation purposes. You can create strings for other languages, e.g. strings_ru, HikkaDynamicTranslate will automatically read this translation and apply it if neccessary. Example:

...
strings = {"name": "SomeModuleName", "hello_text": "Hello, world!"}
strings_ru = {"hello_text": "–ü—Ä–∏–≤–µ—Ç, –º–∏—Ä!"}
...
await utils.answer(message, self.strings("hello_text"))
db
Get database value and replace it with default if not present:

self.get(key: str, default: Any = None)
Example:

self.get("token")
self.get("token", False")
self.get("state", True)
Set database value

self.set(key: str, value: str)
Example:

self.set("token", None)
self.set("state", True)"

"Scopes
You can use scopes in your codes. They are basically single-line comments, which are parsed by Hikka and t.me/hikkamods_bot

# scope: hikka_only - Redundant: Modules, which are supported only on Hikka
# scope: inline - Modules, which use inline features. This scope doesn't affect module directly
# scope: hikka_min 1.1.1 - Specify, which version of Hikka is required for your module to work properly
# scope: no_stats [1.2.10+] - Don't collect stats about your module loading (you can see stats in t.me/hikkamods_bot [/stats command] if you are a trusted developer)
# meta developer: @hikkamods - Specify the developer of module. If channel is specified, Hikka will suggest to subscribe and username will become clickable
# meta pic: https://img.icons8.com/cotton/344/moon-satellite.png - Specify link to module icon. Will be used in @hikkamods_bot
# meta banner: https://mods.hikariatama.ru/badges/spotify.jpg - Specify banner link. Will be used in @hikkamods_bot
# requires: Pillow requests spotipy - Specify requirements to install. If left unspecified, Hikka will try to determine requirements from error, but they're not always correct"
